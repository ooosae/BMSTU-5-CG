\chapter{Технологическая часть}

В данном разделе описаны средства реализации, диаграмма классов, а так же интерфейс ПО. Так же представлены реализованные алгоритмы, которые были выбраны ранее.

\section{Средства реализации}
Для реализации программного обеспечения был выбран язык C\# по следующим причинам:
\begin{enumerate}
	\item Он поддерживает объектно-ориентированный стиль программирования;
	\item Личный опыт разработки на данном языке позволяет эффективно решать поставленные задачи;
	\item Язык обладает высокой производительностью, что важно при трассировке лучей и выполнении вычислений на процессоре.
\end{enumerate}

В качестве среды разработки был выбран Visual Studio, поскольку она достаточно удобна и обладает всем необходимым функционалом для реализации поставленной задачи. В частности, использование библиотеки WPF позволяет реализовать современный и функциональный пользовательский интерфейс, а средства Visual Studio упрощают разработку этого интерфейса.

\section{Диаграмма классов}
На рисунке ниже представлена UML-диаграмма классов. Она отображает структуру и взаимосвязи между  классами, что позволяет наглядно представить архитектуру программного обеспечения и взаимодействие его компонентов.

\begin{table}[H]
	\centering
	\begin{tabular}{p{1\linewidth}}
		\centering
		\includegraphics[width=1.0\linewidth]{include/3-1.drawio.png}
		\captionof{figure}{UML-диаграмма}
		\label{img:3-1}
	\end{tabular}
\end{table}

\section{Реализация алгоритмов}

Рассмотрим класс, реализующий логику лучей и их пересечения с объектами.
\begin{lstlisting}[caption={Класс IntersectionService}, label={lst:3-2}]
public static class IntersectionService
{
	public static void ClosestIntersection(Scene scene, Vector3 camera, Vector3 direction, double tMin, double tMax, out double closestT, out Sphere? closestSphere)
	{
		closestT = double.PositiveInfinity;
		closestSphere = null;
		
		foreach (var sphere in scene.Spheres)
		{
			IntersectRaySphere(camera, direction, sphere, out double t1, out double t2);
			
			if (tMin <= t1 && t1 <= tMax && t1 < closestT)
			{
				closestT = t1;
				closestSphere = sphere;
			}
			
			if (tMin <= t2 && t2 <= tMax && t2 < closestT)
			{
				closestT = t2;
				closestSphere = sphere;
			}
		}
	}
	
	private static void IntersectRaySphere(Vector3 camera, Vector3 direction, Sphere sphere, out double t1, out double t2)
	{
		Vector3 oc = camera - sphere.Center;
		double a = Vector3.DotProduct(direction, direction);
		double b = 2.0 * Vector3.DotProduct(oc, direction);
		double c = Vector3.DotProduct(oc, oc) - sphere.Radius * sphere.Radius;
		double discriminant = b * b - 4 * a * c;
		
		if (discriminant < 0)
		{
			t1 = t2 = double.PositiveInfinity;
		}
		else
		{
			double sqrtDiscriminant = Math.Sqrt(discriminant);
			t1 = (-b - sqrtDiscriminant) / (2.0 * a);
			t2 = (-b + sqrtDiscriminant) / (2.0 * a);
		}
	}
	
	public static Vector3 ReflectRay(Vector3 direction, Vector3 normal)
	{
		double dotProduct = Vector3.DotProduct(direction, normal);
		return  normal * (2 * dotProduct) - direction;
	}
}
\end{lstlisting}

Теперь представим класс, отвечающий за внедрение света.
\begin{lstlisting}[caption={Класс LightService}, label={lst:3-3}]
public static class LightService
{
	public static double ComputeLighting(Scene scene, Vector3 point, Vector3 normal, Vector3 view, double specular)
	{
		double intensity = 0;
		
		foreach (var ambient in scene.Lights.AmbientLights)
		intensity += ambient.Intensity;
		
		foreach (var pointLight in scene.Lights.PointLights)
		{
			Vector3 lightDir = pointLight.Position - point;
			lightDir.Normalize();
			intensity += ComputeDiffuseSpecular(point, normal, view, lightDir, pointLight.Intensity, specular);
		}
		
		foreach (var directional in scene.Lights.DirectionalLights)
		{
			Vector3 lightDir = new Vector3(directional.Direction.X, directional.Direction.Y, directional.Direction.Z);
			lightDir.Normalize();
			intensity += ComputeDiffuseSpecular(point, normal, view, lightDir, directional.Intensity, specular);
		}
		
		return intensity;
	}
	
	private static double ComputeDiffuseSpecular(Vector3 point, Vector3 normal, Vector3 view, Vector3 lightDir, double lightIntensity, double specular)
	{
		double diffuseIntensity = Vector3.DotProduct(normal, lightDir) * lightIntensity;
		diffuseIntensity = Math.Max(diffuseIntensity, 0);
		
		double specularIntensity = 0;
		if (specular >= 0)
		{
			Vector3 reflectDir = IntersectionService. ReflectRay(lightDir, normal);
			double spec = Vector3.DotProduct(reflectDir, view);
			if (spec > 0)
			{
				specularIntensity = Math.Pow(spec, specular) * lightIntensity;
			}
		}
		
		return Math.Max(0, Math.Min(1, diffuseIntensity + specularIntensity));
	}
}
\end{lstlisting}

Осталось рассмотреть класс который отвечает за саму трассировку.

\begin{lstlisting}[caption={Класс RayTracingService}, label={lst:3-5}]
public static class RayTracingService
{
	public static async Task<Color> TraceRayAsync(Scene scene, Vector3 camera, Vector3 direction, double tMin, double tMax, int recursionDepth)
	{
		IntersectionService.ClosestIntersection(scene, camera, direction, tMin, tMax, out double closestT, out Sphere? closestSphere);
		
		if (closestSphere == null)
		{
			return Colors.LightGray;
		}
		
		Vector3 intersectionPoint = camera + direction * closestT;
		Vector3 normal = intersectionPoint - closestSphere.Center;
		normal.Normalize();
		
		if (closestSphere.Texture != null)
		{
			Color textureColor = await GetColorFromTextureAsync(closestSphere, normal);
			normal = AdjustNormalWithTexture(closestSphere.Texture, normal, textureColor);
			normal.Normalize();
		}
		
		Vector3 viewDirection = -direction;
		double intensity = LightService.ComputeLighting(scene, intersectionPoint, normal, viewDirection, closestSphere.Specular);
		Color localColor = AdjustIntensity(closestSphere.Color, intensity);
		
		double reflectivity = closestSphere.Reflective;
		if (recursionDepth <= 0 || reflectivity <= 0)
		{
			return localColor;
		}
		
		Vector3 reflectionDirection = IntersectionService.ReflectRay(viewDirection, normal);
		Color reflectionColor = await TraceRayAsync(scene, intersectionPoint, reflectionDirection, 0.001, double.PositiveInfinity, recursionDepth - 1);
		Color finalColor = AdjustReflection(localColor, reflectionColor, reflectivity);
		
		return finalColor;
	}
	
	private static Color AdjustIntensity(Color color, double intensity)
	{
		byte r = (byte)Math.Min(255, Math.Max(0, color.R * intensity));
		byte g = (byte)Math.Min(255, Math.Max(0, color.G * intensity));
		byte b = (byte)Math.Min(255, Math.Max(0, color.B * intensity));
		return Color.FromRgb(r, g, b);
	}
	
	private static Color AdjustReflection(Color localColor, Color reflectionColor, double reflectivity)
	{
		byte r = (byte)Math.Min(255, Math.Max(0, localColor.R * (1 - reflectivity) + reflectionColor.R * reflectivity));
		byte g = (byte)Math.Min(255, Math.Max(0, localColor.G * (1 - reflectivity) + reflectionColor.G * reflectivity));
		byte b = (byte)Math.Min(255, Math.Max(0, localColor.B * (1 - reflectivity) + reflectionColor.B * reflectivity));
		return Color.FromRgb(r, g, b);
	}
	
	private static async Task<Color> GetColorFromTextureAsync(Sphere sphere, Vector3 normal)
	{
		double u = 0;
		double v = 0;
		
		ComputeTextureCoordinates(normal, ref u, ref v);
		
		int x = (int)(u * sphere.Texture?.PixelWidth ?? 0);
		int y = (int)(v * sphere.Texture?.PixelHeight ?? 0);
		
		var pixels = new byte[4];
		
		await Application.Current.Dispatcher.InvokeAsync(() =>
		{
			sphere.Texture?.CopyPixels(new Int32Rect(x, y, 1, 1), pixels, 4, 0);
		});
		
		return Color.FromArgb(pixels[3], pixels[2], pixels[1], pixels[0]);
	}
	
	private static void ComputeTextureCoordinates(Vector3 normal, ref double u, ref double v)
	{
		double phi = Math.Atan2(normal.Y, normal.X);
		double theta = Math.Acos(normal.Z);
		
		u = (phi + Math.PI) / (2.0 * Math.PI);
		v = theta / Math.PI;
	}
	
	private static Vector3 AdjustNormalWithTexture(BitmapSource texture, Vector3 normal, Color textureColor)
	{
		double Bu = textureColor.R / 255.0;
		double Bv = textureColor.G / 255.0;
		Vector3 Nb = new Vector3(Bu, Bv, 1);
		Nb.Normalize();
		
		Vector3 T = Vector3.CrossProduct(normal, Nb);
		T.Normalize();
		
		Vector3 B = Vector3.CrossProduct(normal, T);
		B.Normalize();
		
		Vector3 Nt = new Vector3(
		Vector3.DotProduct(T, Nb),
		Vector3.DotProduct(B, Nb),
		Vector3.DotProduct(normal, Nb));
		
		return normal + Nt;
	}
}
\end{lstlisting}

Для ускорения работы программы методы трассировки был реализованы асинхронными, поскольку алгоритм позволяет производить вычисления для каждого из лучей не зависимо от предыдущих и последующих результатов. Это очень сильно ускоряет работу программы и позволяет сделать интерфейс более отзывчивым, а работу в программе более приятной для пользователя.

\section{Интерфейс программного обеспечения}

На рисунке \ref{img:3-2} представлен интерфейс программы.

\begin{table}[H]
	\centering
	\begin{tabular}{p{1\linewidth}}
		\centering
		\includegraphics[width=1.0\linewidth]{include/3-2.png}
		\captionof{figure}{Интерфейс ПО}
		\label{img:3-2}
	\end{tabular}
\end{table}

В левой часте экрана расположены списки всех сфер на сцене и света на сцене, а так же различные кнопки: добавления и удаления сфер, добавления текстур на сферу, перемещения и вращения камеры, добавления и удаления света.

\section*{Вывод}
В этом разделе были выбраны средства реализации программы и составлена диаграмма классов, представлена реализация алгоритмов и пользовательский интерфейс.
